using QuantumBinding.Generator;
using QuantumBinding.Generator.CodeGeneration;
using QuantumBinding.Generator.ProcessingFluentApi;
using QuantumBinding.Generator.Processors;
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using QuantumBinding.Generator.Utils;

namespace AdamantiumVulkan.Generator
{
    public class VulkanBindingGenerator : QuantumBindingGenerator
    {
        private Module vkMainModule;
        private Module shaderModule;
        private Module spivCrossModule;
        private Module spivToolsModule;

        public override void OnSetup(BindingOptions options)
        {
            string header = @$"
            ----------------------------------------------------------------------------------------------
            <auto-generated>
            This file was autogenerated by {GeneratorName}.
            Do not edit this file manually, because you will lose all your changes after next generation.
            </auto-generated>
            ----------------------------------------------------------------------------------------------";
            
            string vkMainLibrary = "vulkan-1";
            string shadercLibrary = "shaderc_shared";
            string spirvCrossLibrary = "spirv-cross-c-shared";
            string spirvToolsLibrary = "SPIRV-Tools-shared";
            string mainNamespace = "AdamantiumVulkan";
            string vulkanBasePath = @"C:\VulkanSDK\1.4.309.0\Include";
            string interopSubNamespace = "Interop";

            var appRoot = AppContext.BaseDirectory.Substring(0, AppContext.BaseDirectory.LastIndexOf("bin"));
            string corePath = Path.GetFullPath(Path.Combine(appRoot, "..", "AdamantiumVulkan.Core", "Generated"));
            string windowsPath = Path.GetFullPath(Path.Combine(appRoot, "..", "AdamantiumVulkan.Windows", "Generated"));
            string macOSPath = Path.GetFullPath(Path.Combine(appRoot, "..", "AdamantiumVulkan.MacOS", "Generated"));
            string shadersPath = Path.GetFullPath(Path.Combine(appRoot, "..", "AdamantiumVulkan.Shaders", "Generated"));
            string spirvPath = Path.GetFullPath(Path.Combine(appRoot, "..", "AdamantiumVulkan.Spirv", "Generated"));
            var spirvToolsPath = (Path.Combine(appRoot, "..", "AdamantiumVulkan.SpirvTools", "Generated"));
            
            PathManager vulkanPathManager = new PathManager();
            vulkanPathManager.AddFilePath(OSPlatform.Windows, Path.Combine(vulkanBasePath, "vulkan", "vulkan.h"));
            vulkanPathManager.AddFilePath(OSPlatform.OSX, Path.Combine("/usr", "local", "include", "vulkan", "vulkan.h"));

            options.GenerateSequentialLayout = true;
            options.PodTypesAsSimpleTypes = false;
            options.PathToBindingsFile = "VulkanBindingsMap.xml";
            options.DebugMode = true;

            vkMainModule = Module.Create(vkMainLibrary);
            vkMainModule.GeneratorMode = GeneratorMode.Preview;
            vkMainModule.CleanPreviousGeneration = true;
            vkMainModule.EachTypeInSeparateFile = true;
            vkMainModule.FileHeader = header;
            vkMainModule.Name = "Core";
            vkMainModule.IncludeDirs.Add(vulkanBasePath);                         
            vkMainModule.IncludeDirs.Add(Path.Combine(vulkanBasePath, "vulkan"));
            vkMainModule.Defines.Add("_WIN32");
            vkMainModule.Defines.Add("_MSC_VER");
            vkMainModule.Defines.Add("VK_USE_PLATFORM_WIN32_KHR");
            vkMainModule.Defines.Add("VK_USE_PLATFORM_MACOS_MVK");
            vkMainModule.Files.AddRange(vulkanPathManager.Files);
            vkMainModule.ForceCallingConvention = false;
            vkMainModule.InteropClassAccessSpecifier = AccessSpecifier.Internal;
            vkMainModule.CallingConvention = CallingConvention.Winapi;
            vkMainModule.AllowConvertStructToClass = true;
            vkMainModule.MethodClassName = "VulkanNative";
            vkMainModule.InteropClassName = "VulkanInterop";
            vkMainModule.OutputFileName = mainNamespace;
            vkMainModule.OutputNamespace = mainNamespace;
            vkMainModule.InteropSubNamespace = interopSubNamespace;
            vkMainModule.SuppressUnmanagedCodeSecurity = false;
            vkMainModule.AddNamespaceMapping("vulkan_core", "Core", corePath);
            vkMainModule.AddNamespaceMapping("vulkan_win32", "Windows", windowsPath);
            vkMainModule.AddNamespaceMapping("vulkan_macos", "MacOS", macOSPath);
            vkMainModule.WrapInteropObjects = true;
            vkMainModule.GenerateOverloadsForArrayParams = true;
            vkMainModule.GeneratorSpecializations = GeneratorSpecializations.All;
            vkMainModule.OutputPath = corePath;
            
            shaderModule = Module.Create(shadercLibrary);
            shaderModule.FileHeader = header;
            shaderModule.GeneratorMode = GeneratorMode.Compatible;
            shaderModule.EachTypeInSeparateFile = true;
            shaderModule.CleanPreviousGeneration = true;
            shaderModule.Name = "Shaders";
            shaderModule.IncludeDirs.Add(vulkanBasePath);
            shaderModule.IncludeDirs.Add(Path.Combine(vulkanBasePath, "shaderc"));
            shaderModule.Files.Add(Path.Combine(vulkanBasePath, "shaderc", "shaderc.h"));
            shaderModule.Defines.Add("SHADERC_SHAREDLIB");
            shaderModule.Defines.Add("_WIN32");
            shaderModule.Defines.Add("SHADERC_IMPLEMENTATION");
            shaderModule.ForceCallingConvention = false;
            shaderModule.CallingConvention = CallingConvention.Winapi;
            shaderModule.AllowConvertStructToClass = true;
            shaderModule.MethodClassName = "VulkanShadersNative";
            shaderModule.InteropClassName = "VulkanShadersInterop";
            shaderModule.GeneratorSpecializations = GeneratorSpecializations.All;
            shaderModule.OutputFileName = "AdamantiumVulkan.Shaders";
            shaderModule.OutputNamespace = "AdamantiumVulkan.Shaders";
            shaderModule.InteropSubNamespace = interopSubNamespace;
            shaderModule.SuppressUnmanagedCodeSecurity = true;
            shaderModule.WrapInteropObjects = true;
            shaderModule.GenerateOverloadsForArrayParams = true;
            shaderModule.OutputPath = shadersPath;
            
            var spirvCrossSpecs = GeneratorSpecializationUtils.AllExcept(GeneratorSpecializations.Macros);
            spivCrossModule = Module.Create(spirvCrossLibrary);
            spivCrossModule.FileHeader = header;
            spivCrossModule.GeneratorMode = GeneratorMode.Compatible;
            spivCrossModule.EachTypeInSeparateFile = true;
            spivCrossModule.CleanPreviousGeneration = true;
            spivCrossModule.Name = "Spirv.Cross";
            spivCrossModule.Files.Add(Path.Combine(vulkanBasePath, "spirv_cross", "spirv_cross_c.h"));
            spivCrossModule.Defines.Add("SPVC_EXPORT_SYMBOLS");
            spivCrossModule.Defines.Add("_MSC_VER");
            spivCrossModule.ForceCallingConvention = true;
            spivCrossModule.CallingConvention = CallingConvention.Winapi;
            spivCrossModule.AllowConvertStructToClass = true;
            spivCrossModule.MethodClassName = "SpirvCrossNative";
            spivCrossModule.InteropClassName = "SpirvCrossInterop";
            spivCrossModule.GeneratorSpecializations = spirvCrossSpecs;
            spivCrossModule.OutputFileName = "AdamantiumVulkan.Spirv.Cross";
            spivCrossModule.OutputNamespace = "AdamantiumVulkan.Spirv.Cross";
            spivCrossModule.InteropSubNamespace = interopSubNamespace;
            spivCrossModule.SuppressUnmanagedCodeSecurity = true;
            spivCrossModule.AddNamespaceMapping("spirv", "AdamantiumVulkan.Spirv", spirvPath, true);
            spivCrossModule.WrapInteropObjects = true;
            spivCrossModule.CharAsBoolForMethods = true;
            spivCrossModule.OutputPath = spirvPath;
            
            var spirvToolsSpecs = GeneratorSpecializationUtils.AllExcept(GeneratorSpecializations.Macros);
            spivToolsModule = Module.Create(spirvToolsLibrary);
            spivToolsModule.FileHeader = header;
            spivToolsModule.GeneratorMode = GeneratorMode.Compatible;
            spivToolsModule.EachTypeInSeparateFile = true;
            spivToolsModule.CleanPreviousGeneration = true;
            spivToolsModule.Name = "SpirvTools";
            spivToolsModule.Files.Add(Path.Combine(vulkanBasePath, "spirv-tools", "libspirv.h"));
            spivToolsModule.Defines.Add("SPIRV_TOOLS_EXPORT");
            spivToolsModule.Defines.Add("_WIN32");
            spivToolsModule.ForceCallingConvention = true;
            spivToolsModule.CallingConvention = CallingConvention.Winapi;
            spivToolsModule.AllowConvertStructToClass = true;
            spivToolsModule.MethodClassName = "SpirvToolsNative";
            spivToolsModule.InteropClassName = "SpirvToolsInterop";
            spivToolsModule.GeneratorSpecializations = spirvToolsSpecs;
            spivToolsModule.OutputFileName = "AdamantiumVulkan.SpirvTools";
            spivToolsModule.OutputNamespace = "AdamantiumVulkan.SpirvTools";
            spivToolsModule.InteropSubNamespace = interopSubNamespace;
            spivToolsModule.SuppressUnmanagedCodeSecurity = true;
            spivToolsModule.AddNamespaceMapping("libspirv", "AdamantiumVulkan.SpirvTools", spirvToolsPath, true);
            spivToolsModule.WrapInteropObjects = true;
            spivToolsModule.CharAsBoolForMethods = true;
            spivToolsModule.OutputPath = spirvToolsPath;
            
            options.AddModule(vkMainModule);
            options.AddModule(shaderModule);
            options.AddModule(spivCrossModule);
            options.AddModule(spivToolsModule);
        }

        public override void OnBeforeSetupPasses(ProcessingContext context)
        {
            VulkanBindings.ProvideFunctionsForParametersFix(context);
            VulkanBindings.ReplaceTypedefsToEnums(context);
        }

        public override void OnSetupPostProcessing(ProcessingContext context)
        {
            var functionToInstance = new FunctionToInstanceMethodPass();
            functionToInstance.SkipOverloadForFunctions(
                "vkEnumeratePhysicalDevices", 
                "vkGetPhysicalDeviceSurfaceFormatsKHR",
                "vkGetPhysicalDeviceSurfacePresentModesKHR",
                "vkGetPhysicalDeviceQueueFamilyProperties",
                "vkEnumerateDeviceExtensionProperties",
                "vkEnumerateInstanceExtensionProperties",
                "vkEnumerateInstanceLayerProperties",
                "vkCmdPipelineBarrier");
            
            context.AddPreGeneratorPass(functionToInstance, ExecutionPassKind.PerTranslationUnit);
            context.AddPreGeneratorPass(new ForceCallingConventionPass(CallingConvention.Winapi), ExecutionPassKind.PerTranslationUnit);
            context.AddPreGeneratorPass(new CheckFlagsEnumsPass(), ExecutionPassKind.PerTranslationUnit);
            context.AddPreGeneratorPass(new EnumItemsCleanupPass(), ExecutionPassKind.PerTranslationUnit);
            context.AddPreGeneratorPass(new EnumItemsRenamePass(CasePattern.PascalCase, "VkFormat"), ExecutionPassKind.PerTranslationUnit);
            context.AddPreGeneratorPass(new EnumItemsExcludePass(ExcludeCheck.StartsWithIgnoreCase, "BeginRange", "EndRange"), ExecutionPassKind.PerTranslationUnit);
            
            var renameTargets = RenameTargetsUtils.AnyExcept(RenameTargets.Struct | RenameTargets.Union | RenameTargets.Function);
            var vkRenameItems = new List<RegexRenameRunItem>()
            {
                new RegexRenameRunItem("^vkCmd", string.Empty, renameTargets, true),
                new RegexRenameRunItem("^vk", string.Empty, renameTargets, true),
            };
            context.AddPreGeneratorPass(new SequentialRegexRenamePass(vkRenameItems.ToArray()), ExecutionPassKind.PerTranslationUnit, vkMainModule);

            renameTargets = RenameTargetsUtils.AnyExcept(RenameTargets.Function | RenameTargets.Struct);

            var shadercRenameItems = new List<RegexRenameRunItem>()
            {
                new RegexRenameRunItem("^shaderc_compile_options", string.Empty, RenameTargets.Method, true),
                new RegexRenameRunItem("^shaderc_result", string.Empty, RenameTargets.Method, true),
                new RegexRenameRunItem("^shaderc", string.Empty, RenameTargets.Method, true),
            };
            context.AddPreGeneratorPass(new SequentialRegexRenamePass(shadercRenameItems.ToArray()), ExecutionPassKind.PerTranslationUnit, shaderModule);

            var spirvRenameTargets = RenameTargetsUtils.AnyExcept(RenameTargets.Function).
                Except(RenameTargets.Struct).
                Except(RenameTargets.Union);

            var spvcRenameItems = new List<RegexRenameRunItem>()
            {
                new RegexRenameRunItem("^spvc_resources", string.Empty, RenameTargets.Method, true),
                new RegexRenameRunItem("^spvc_compiler_options", string.Empty, RenameTargets.Method, true),
                new RegexRenameRunItem("^spvc_compiler", string.Empty, RenameTargets.Method, true),
                new RegexRenameRunItem("^spvc_constant", string.Empty, RenameTargets.Method, true),
                new RegexRenameRunItem("^spvc_context", string.Empty, RenameTargets.Method, true),
                new RegexRenameRunItem("^spvc_type", string.Empty, RenameTargets.Method, true),
                new RegexRenameRunItem("^spvc", "spirv", RenameTargets.Class, true),
                new RegexRenameRunItem("^spvc", string.Empty, spirvRenameTargets, true),
            };

            context.AddPreGeneratorPass(new SequentialRegexRenamePass(spvcRenameItems.ToArray()), ExecutionPassKind.PerTranslationUnit, spivCrossModule);

            context.AddPreGeneratorPass(new CaseRenamePass(renameTargets, CasePattern.PascalCase), ExecutionPassKind.PerTranslationUnit, shaderModule);
            context.AddPreGeneratorPass(new CaseRenamePass(renameTargets, CasePattern.PascalCase), ExecutionPassKind.PerTranslationUnit, spivCrossModule);

            context.AddPreGeneratorPass(new PrepareStructsBeforeWrappingPass(VulkanBindings.PredefinedInput.GetPredefinedStructuresValues()), ExecutionPassKind.PerTranslationUnit);

            var disposableList = new List<DisposableExtension>();
            disposableList.Add(new DisposableExtension() { Name = "Instance", DisposableContent = "DestroyInstance();" });
            disposableList.Add(new DisposableExtension() { Name = "Device", DisposableContent = "DestroyDevice();" });

            var disposable = new DisposableExtensionPass(disposableList.ToArray()) { OutputFileName = "Extensions", GeneratorSpecializations = GeneratorSpecializations.Extensions};
            context.AddCodeGenerationPass(disposable, ExecutionPassKind.PerTranslationUnit);

            var macroAction = new MacroFunctionsToCSharpFunctionsPass();
            macroAction.IgnoreList.Add("VK_USE_PLATFORM_WIN32_KHR");
            macroAction.IgnoreList.Add("_WIN32");
            macroAction.IgnoreList.Add("VULKAN_H_");
            macroAction.IgnoreList.Add("VKAPI_CALL");
            macroAction.IgnoreList.Add("VULKAN_CORE_H_");
            macroAction.IgnoreList.Add("VKAPI_PTR");
            macroAction.IgnoreList.Add("VK_NULL_HANDLE");
            macroAction.IgnoreList.Add("VK_DEFINE_HANDLE");
            macroAction.IgnoreList.Add("VK_DEFINE_NON_DISPATCHABLE_HANDLE");
            macroAction.IgnoreList.Add("SHADERC_EXPORT");
            macroAction.IgnoreList.Add("SHADERC_IMPLEMENTATION");
            macroAction.IgnoreList.Add("SHADERC_SHAREDLIB");
            macroAction.IgnoreList.Add("VK_MAKE_VERSION");
            macroAction.IgnoreList.Add("VK_VERSION_MAJOR");
            macroAction.IgnoreList.Add("VK_VERSION_MINOR");
            macroAction.IgnoreList.Add("VK_VERSION_PATCH");

            macroAction.SubstitutionList.Add("VK_MAKE_API_VERSION", VulkanBindings.MacroFunctions.CreateMakeApiVersionFunction());
            macroAction.SubstitutionList.Add("VK_API_VERSION_VARIANT", VulkanBindings.MacroFunctions.CreateApiVersionFor("variant"));
            macroAction.SubstitutionList.Add("VK_API_VERSION_MAJOR", VulkanBindings.MacroFunctions.CreateApiVersionFor("major"));
            macroAction.SubstitutionList.Add("VK_API_VERSION_MINOR", VulkanBindings.MacroFunctions.CreateApiVersionFor("minor"));
            macroAction.SubstitutionList.Add("VK_API_VERSION_PATCH", VulkanBindings.MacroFunctions.CreateApiVersionFor("patch"));
            macroAction.SubstitutionList.Add("VK_API_VERSION_1_0", VulkanBindings.MacroFunctions.CreateApiVersion());
            macroAction.SubstitutionList.Add("VK_API_VERSION_1_1", VulkanBindings.MacroFunctions.CreateApiVersion());
            macroAction.SubstitutionList.Add("VK_QUEUE_FAMILY_EXTERNAL_KHR", VulkanBindings.MacroFunctions.CreateApiVersion());
            macroAction.SubstitutionList.Add("VK_QUEUE_FAMILY_EXTERNAL", VulkanBindings.MacroFunctions.CreateApiVersion());
            macroAction.SubstitutionList.Add("VK_QUEUE_FAMILY_FOREIGN_EXT", VulkanBindings.MacroFunctions.CreateApiVersion());
            macroAction.SubstitutionList.Add("VK_HEADER_VERSION", VulkanBindings.MacroFunctions.CreateHeaderVersion());
            macroAction.SubstitutionList.Add("VK_LOD_CLAMP_NONE", VulkanBindings.MacroFunctions.CreateLodClampNone());
            macroAction.SubstitutionList.Add("VK_KHR_MAINTENANCE1_EXTENSION_NAME", VulkanBindings.MacroFunctions.CreateStringReturnMacro());
            macroAction.SubstitutionList.Add("VK_KHR_MAINTENANCE2_EXTENSION_NAME", VulkanBindings.MacroFunctions.CreateStringReturnMacro());
            macroAction.SubstitutionList.Add("VK_KHR_MAINTENANCE3_EXTENSION_NAME", VulkanBindings.MacroFunctions.CreateStringReturnMacro());
            macroAction.SubstitutionList.Add("VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME", VulkanBindings.MacroFunctions.CreateStringReturnMacro());
            macroAction.SubstitutionList.Add("VK_GOOGLE_HLSL_FUNCTIONALITY1_EXTENSION_NAME", VulkanBindings.MacroFunctions.CreateStringReturnMacro());
            
            macroAction.SubstitutionList.Add("VP_KHR_ROADMAP_2022_MIN_API_VERSION", VulkanBindings.MacroFunctions.CreateMakeProfileVersionFunction(1, 3, 204));
            macroAction.SubstitutionList.Add("VP_LUNARG_DESKTOP_BASELINE_2022_MIN_API_VERSION", VulkanBindings.MacroFunctions.CreateMakeProfileVersionFunction(1, 1, 139));
            
            // Spirv constansts part
            macroAction.IgnoreList.Add("SPVC_PUBLIC_API");
            macroAction.IgnoreList.Add("SPVC_TRUE");
            macroAction.IgnoreList.Add("SPVC_FALSE");
            
            macroAction.SubstitutionList.Add("SPVC_MAKE_MSL_VERSION", VulkanBindings.MacroFunctions.CreateSpirvMSLVersion());
            macroAction.SubstitutionList.Add("VK_MAKE_VIDEO_STD_VERSION", VulkanBindings.MacroFunctions.CreateMakeVideoStdVersion());
            
            context.AddPreGeneratorPass(macroAction, ExecutionPassKind.PerTranslationUnit);
        }

        public override void OnSetupComplete(ProcessingContext context)
        {
            var renameTargets =
                RenameTargetsUtils.AnyExcept(RenameTargets.Struct | RenameTargets.Union | RenameTargets.Function);
            var vkRenameItems = new List<RegexRenameRunItem>()
            {
                new RegexRenameRunItem("^vkCmd", string.Empty, renameTargets, true),
                new RegexRenameRunItem("^vk", string.Empty, renameTargets, true),
            };
            context.AddPreGeneratorPass(new SequentialRegexRenamePass(vkRenameItems.ToArray()), ExecutionPassKind.PerTranslationUnit, vkMainModule);
        }
    }

}
