// ----------------------------------------------------------------------------------------------
// <auto-generated>
// This file was autogenerated by QuantumBindingGenerator.
// Do not edit this file manually, because you will lose all your changes after next generation.
// </auto-generated>
// ----------------------------------------------------------------------------------------------

namespace AdamantiumVulkan.Shaders
{
    using System;
    using System.Runtime.InteropServices;

    ///<summary>
    /// Source language kind.
    ///</summary>
    [Flags]
    public enum ShadercSourceLanguage : int
    {
        Glsl = 0,

        Hlsl = 1,

    }

    public enum ShadercShaderKind : int
    {
        ///<summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the source code as the specified kind of shader.
        ///</summary>
        VertexShader = 0,

        ///<summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the source code as the specified kind of shader.
        ///</summary>
        FragmentShader = 1,

        ///<summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the source code as the specified kind of shader.
        ///</summary>
        ComputeShader = 2,

        ///<summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the source code as the specified kind of shader.
        ///</summary>
        GeometryShader = 3,

        ///<summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the source code as the specified kind of shader.
        ///</summary>
        TessControlShader = 4,

        ///<summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the source code as the specified kind of shader.
        ///</summary>
        TessEvaluationShader = 5,

        ///<summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the source code as the specified kind of shader.
        ///</summary>
        GlslVertexShader = 0,

        ///<summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the source code as the specified kind of shader.
        ///</summary>
        GlslFragmentShader = 1,

        ///<summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the source code as the specified kind of shader.
        ///</summary>
        GlslComputeShader = 2,

        ///<summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the source code as the specified kind of shader.
        ///</summary>
        GlslGeometryShader = 3,

        ///<summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the source code as the specified kind of shader.
        ///</summary>
        GlslTessControlShader = 4,

        ///<summary>
        /// Forced shader kinds. These shader kinds force the compiler to compile the source code as the specified kind of shader.
        ///</summary>
        GlslTessEvaluationShader = 5,

        ///<summary>
        /// Deduce the shader kind from #pragma annotation in the source code. Compiler will emit error if #pragma annotation is not found.
        ///</summary>
        GlslInferFromSource = 6,

        ///<summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as the specified kind of shader when #pragma annotation is not found in the source code.
        ///</summary>
        GlslDefaultVertexShader = 7,

        ///<summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as the specified kind of shader when #pragma annotation is not found in the source code.
        ///</summary>
        GlslDefaultFragmentShader = 8,

        ///<summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as the specified kind of shader when #pragma annotation is not found in the source code.
        ///</summary>
        GlslDefaultComputeShader = 9,

        ///<summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as the specified kind of shader when #pragma annotation is not found in the source code.
        ///</summary>
        GlslDefaultGeometryShader = 10,

        ///<summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as the specified kind of shader when #pragma annotation is not found in the source code.
        ///</summary>
        GlslDefaultTessControlShader = 11,

        ///<summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as the specified kind of shader when #pragma annotation is not found in the source code.
        ///</summary>
        GlslDefaultTessEvaluationShader = 12,

        ///<summary>
        /// Default shader kinds. Compiler will fall back to compile the source code as the specified kind of shader when #pragma annotation is not found in the source code.
        ///</summary>
        SpirvAssembly = 13,

    }

    public enum ShadercProfile : int
    {
        ///<summary>
        /// Used if and only if GLSL version did not specify profiles.
        ///</summary>
        None = 0,

        Core = 1,

        Compatibility = 2,

        Es = 3,

    }

    ///<summary>
    /// Optimization level.
    ///</summary>
    [Flags]
    public enum ShadercOptimizationLevel : int
    {
        ///<summary>
        /// no optimization
        ///</summary>
        Zero = 0,

        ///<summary>
        /// optimize towards reducing code size
        ///</summary>
        Size = 1,

        ///<summary>
        /// optimize towards performance
        ///</summary>
        Performance = 2,

    }

    ///<summary>
    /// Resource limits.
    ///</summary>
    public enum ShadercLimit : int
    {
        MaxLights = 0,

        MaxClipPlanes = 1,

        MaxTextureUnits = 2,

        MaxTextureCoords = 3,

        MaxVertexAttribs = 4,

        MaxVertexUniformComponents = 5,

        MaxVaryingFloats = 6,

        MaxVertexTextureImageUnits = 7,

        MaxCombinedTextureImageUnits = 8,

        MaxTextureImageUnits = 9,

        MaxFragmentUniformComponents = 10,

        MaxDrawBuffers = 11,

        MaxVertexUniformVectors = 12,

        MaxVaryingVectors = 13,

        MaxFragmentUniformVectors = 14,

        MaxVertexOutputVectors = 15,

        MaxFragmentInputVectors = 16,

        MinProgramTexelOffset = 17,

        MaxProgramTexelOffset = 18,

        MaxClipDistances = 19,

        MaxComputeWorkGroupCountX = 20,

        MaxComputeWorkGroupCountY = 21,

        MaxComputeWorkGroupCountZ = 22,

        MaxComputeWorkGroupSizeX = 23,

        MaxComputeWorkGroupSizeY = 24,

        MaxComputeWorkGroupSizeZ = 25,

        MaxComputeUniformComponents = 26,

        MaxComputeTextureImageUnits = 27,

        MaxComputeImageUniforms = 28,

        MaxComputeAtomicCounters = 29,

        MaxComputeAtomicCounterBuffers = 30,

        MaxVaryingComponents = 31,

        MaxVertexOutputComponents = 32,

        MaxGeometryInputComponents = 33,

        MaxGeometryOutputComponents = 34,

        MaxFragmentInputComponents = 35,

        MaxImageUnits = 36,

        MaxCombinedImageUnitsAndFragmentOutputs = 37,

        MaxCombinedShaderOutputResources = 38,

        MaxImageSamples = 39,

        MaxVertexImageUniforms = 40,

        MaxTessControlImageUniforms = 41,

        MaxTessEvaluationImageUniforms = 42,

        MaxGeometryImageUniforms = 43,

        MaxFragmentImageUniforms = 44,

        MaxCombinedImageUniforms = 45,

        MaxGeometryTextureImageUnits = 46,

        MaxGeometryOutputVertices = 47,

        MaxGeometryTotalOutputComponents = 48,

        MaxGeometryUniformComponents = 49,

        MaxGeometryVaryingComponents = 50,

        MaxTessControlInputComponents = 51,

        MaxTessControlOutputComponents = 52,

        MaxTessControlTextureImageUnits = 53,

        MaxTessControlUniformComponents = 54,

        MaxTessControlTotalOutputComponents = 55,

        MaxTessEvaluationInputComponents = 56,

        MaxTessEvaluationOutputComponents = 57,

        MaxTessEvaluationTextureImageUnits = 58,

        MaxTessEvaluationUniformComponents = 59,

        MaxTessPatchComponents = 60,

        MaxPatchVertices = 61,

        MaxTessGenLevel = 62,

        MaxViewports = 63,

        MaxVertexAtomicCounters = 64,

        MaxTessControlAtomicCounters = 65,

        MaxTessEvaluationAtomicCounters = 66,

        MaxGeometryAtomicCounters = 67,

        MaxFragmentAtomicCounters = 68,

        MaxCombinedAtomicCounters = 69,

        MaxAtomicCounterBindings = 70,

        MaxVertexAtomicCounterBuffers = 71,

        MaxTessControlAtomicCounterBuffers = 72,

        MaxTessEvaluationAtomicCounterBuffers = 73,

        MaxGeometryAtomicCounterBuffers = 74,

        MaxFragmentAtomicCounterBuffers = 75,

        MaxCombinedAtomicCounterBuffers = 76,

        MaxAtomicCounterBufferSize = 77,

        MaxTransformFeedbackBuffers = 78,

        MaxTransformFeedbackInterleavedComponents = 79,

        MaxCullDistances = 80,

        MaxCombinedClipAndCullDistances = 81,

        MaxSamples = 82,

    }

    ///<summary>
    /// Uniform resource kinds. In Vulkan, uniform resources are bound to the pipeline via descriptors with numbered bindings and sets.
    ///</summary>
    public enum ShadercUniformKind : int
    {
        ///<summary>
        /// Image and image buffer.
        ///</summary>
        Image = 0,

        ///<summary>
        /// Pure sampler.
        ///</summary>
        Sampler = 1,

        ///<summary>
        /// Sampled texture in GLSL, and Shader Resource View in HLSL.
        ///</summary>
        Texture = 2,

        ///<summary>
        /// Uniform Buffer Object (UBO) in GLSL. Cbuffer in HLSL.
        ///</summary>
        Buffer = 3,

        ///<summary>
        /// Shader Storage Buffer Object (SSBO) in GLSL.
        ///</summary>
        StorageBuffer = 4,

        ///<summary>
        /// Unordered Access View, in HLSL. (Writable storage image or storage buffer.)
        ///</summary>
        UnorderedAccessView = 5,

    }

    ///<summary>
    /// The kinds of include requests.
    ///</summary>
    [Flags]
    public enum ShadercIncludeType : int
    {
        ///<summary>
        /// E.g. #include "source"
        ///</summary>
        Relative = 0,

        ///<summary>
        /// E.g. #include <source>
        ///</summary>
        Standard = 1,

    }


}

