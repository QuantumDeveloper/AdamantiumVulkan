// ----------------------------------------------------------------------------------------------
// <auto-generated>
// This file was autogenerated by QuantumBindingGenerator.
// Do not edit this file manually, because you will lose all your changes after next generation.
// </auto-generated>
// ----------------------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using QuantumBinding.Utils;
using AdamantiumVulkan.Shaders.Interop;

namespace AdamantiumVulkan.Shaders;

// File: C:\VulkanSDK\1.4.304.0\Include\shaderc\shaderc.h Line: 277 Column: 41
///<summary>
/// An opaque handle to an object that manages options to a single compilation result.
///</summary>
public unsafe partial class ShadercCompileOptionsT
{
    internal ShadercCompileOptions __Instance;
    public ShadercCompileOptionsT()
    {
    }

    public ShadercCompileOptionsT(AdamantiumVulkan.Shaders.Interop.ShadercCompileOptions __Instance)
    {
        this.__Instance = __Instance;
    }

    ///<summary>
    /// Adds a predefined macro to the compilation options. This has the same effect as passing -Dname=value to the command-line compiler. If value is NULL, it has the same effect as passing -Dname to the command-line compiler. If a macro definition with the same name has previously been added, the value is replaced with the new value. The macro name and value are passed in with char pointers, which point to their data, and the lengths of their data. The strings that the name and value pointers point to must remain valid for the duration of the call, but can be modified or deleted after this function has returned. In case of adding a valueless macro, the value argument should be a null pointer or the value_length should be 0u.
    ///</summary>
    public void AddMacroDefinition(string name, ulong name_length, string value, ulong value_length)
    {
        var arg1 = (sbyte*)NativeUtils.StringToPointer(name, false);
        var arg3 = (sbyte*)NativeUtils.StringToPointer(value, false);
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_add_macro_definition(this, arg1, name_length, arg3, value_length);
        NativeUtils.Free(arg1);
        NativeUtils.Free(arg3);
    }

    ///<summary>
    /// Returns a copy of the given shaderc_compile_options_t. If NULL is passed as the parameter the call is the same as shaderc_compile_options_init.
    ///</summary>
    public ShadercCompileOptionsT Clone()
    {
        return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_clone(this);
    }

    ///<summary>
    /// Returns a default-initialized shaderc_compile_options_t that can be used to modify the functionality of a compiled module. A return of NULL indicates that there was an error initializing the options. Any function operating on shaderc_compile_options_t must offer the basic thread-safety guarantee.
    ///</summary>
    public static ShadercCompileOptionsT Initialize()
    {
        return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_initialize();
    }

    ///<summary>
    /// Releases the compilation options. It is invalid to use the given shaderc_compile_options_t object in any future calls. It is safe to pass NULL to this function, and doing such will have no effect.
    ///</summary>
    public void Release()
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_release(this);
    }

    ///<summary>
    /// Sets whether the compiler should automatically assign bindings to uniforms that aren't already explicitly bound in the shader source.
    ///</summary>
    public void SetAutoBindUniforms(bool auto_bind)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_auto_bind_uniforms(this, auto_bind);
    }

    ///<summary>
    /// Sets whether the compiler should automatically remove sampler variables and convert image variables to combined image-sampler variables.
    ///</summary>
    public void SetAutoCombinedImageSampler(bool upgrade)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_auto_combined_image_sampler(this, upgrade);
    }

    ///<summary>
    /// Sets whether the compiler should automatically assign locations to uniform variables that don't have explicit locations in the shader source.
    ///</summary>
    public void SetAutoMapLocations(bool auto_map)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_auto_map_locations(this, auto_map);
    }

    ///<summary>
    /// Sets the base binding number used for for a uniform resource type when automatically assigning bindings. For GLSL compilation, sets the lowest automatically assigned number. For HLSL compilation, the regsiter number assigned to the resource is added to this specified base.
    ///</summary>
    public void SetBindingBase(ShadercUniformKind kind, uint @base)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_binding_base(this, kind, @base);
    }

    ///<summary>
    /// Like shaderc_compile_options_set_binding_base, but only takes effect when compiling a given shader stage. The stage is assumed to be one of vertex, fragment, tessellation evaluation, tesselation control, geometry, or compute.
    ///</summary>
    public void SetBindingBaseForStage(ShadercShaderKind shader_kind, ShadercUniformKind kind, uint @base)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_binding_base_for_stage(this, shader_kind, kind, @base);
    }

    ///<summary>
    /// Forces the GLSL language version and profile to a given pair. The version number is the same as would appear in the #version annotation in the source. Version and profile specified here overrides the #version annotation in the source. Use profile: 'shaderc_profile_none' for GLSL versions that do not define profiles, e.g. versions below 150.
    ///</summary>
    public void SetForcedVersionProfile(int version, ShadercProfile profile)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_forced_version_profile(this, version, profile);
    }

    ///<summary>
    /// Sets the compiler mode to generate debug information in the output.
    ///</summary>
    public void SetGenerateDebugInfo()
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_generate_debug_info(this);
    }

    ///<summary>
    /// Sets whether 16-bit types are supported in HLSL or not.
    ///</summary>
    public void SetHlsl16bitTypes(bool enable)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_hlsl_16bit_types(this, enable);
    }

    ///<summary>
    /// Sets whether the compiler should enable extension SPV_GOOGLE_hlsl_functionality1.
    ///</summary>
    public void SetHlslFunctionality1(bool enable)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_hlsl_functionality1(this, enable);
    }

    ///<summary>
    /// Sets whether the compiler should use HLSL IO mapping rules for bindings. Defaults to false.
    ///</summary>
    public void SetHlslIoMapping(bool hlsl_iomap)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_hlsl_io_mapping(this, hlsl_iomap);
    }

    ///<summary>
    /// Sets whether the compiler should determine block member offsets using HLSL packing rules instead of standard GLSL rules. Defaults to false. Only affects GLSL compilation. HLSL rules are always used when compiling HLSL.
    ///</summary>
    public void SetHlslOffsets(bool hlsl_offsets)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_hlsl_offsets(this, hlsl_offsets);
    }

    ///<summary>
    /// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage, but affects all shader stages.
    ///</summary>
    public void SetHlslRegisterSetAndBinding(string reg, string set, string binding)
    {
        var arg1 = (sbyte*)NativeUtils.StringToPointer(reg, false);
        var arg2 = (sbyte*)NativeUtils.StringToPointer(set, false);
        var arg3 = (sbyte*)NativeUtils.StringToPointer(binding, false);
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_hlsl_register_set_and_binding(this, arg1, arg2, arg3);
        NativeUtils.Free(arg1);
        NativeUtils.Free(arg2);
        NativeUtils.Free(arg3);
    }

    ///<summary>
    /// Sets a descriptor set and binding for an HLSL register in the given stage. This method keeps a copy of the string data.
    ///</summary>
    public void SetHlslRegisterSetAndBindingForStage(ShadercShaderKind shader_kind, string reg, string set, string binding)
    {
        var arg2 = (sbyte*)NativeUtils.StringToPointer(reg, false);
        var arg3 = (sbyte*)NativeUtils.StringToPointer(set, false);
        var arg4 = (sbyte*)NativeUtils.StringToPointer(binding, false);
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage(this, shader_kind, arg2, arg3, arg4);
        NativeUtils.Free(arg2);
        NativeUtils.Free(arg3);
        NativeUtils.Free(arg4);
    }

    ///<summary>
    /// Sets includer callback functions.
    ///</summary>
    public void SetIncludeCallbacks(void* resolver, void* result_releaser, ref void* user_data)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_include_callbacks(this, resolver, result_releaser, user_data);
    }

    ///<summary>
    /// Sets whether the compiler should invert position.Y output in vertex shader.
    ///</summary>
    public void SetInvertY(bool enable)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_invert_y(this, enable);
    }

    ///<summary>
    /// Sets a resource limit.
    ///</summary>
    public void SetLimit(ShadercLimit limit, int value)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_limit(this, limit, value);
    }

    ///<summary>
    /// Sets whether the compiler generates code for max and min builtins which, if given a NaN operand, will return the other operand. Similarly, the clamp builtin will favour the non-NaN operands, as if clamp were implemented as a composition of max and min.
    ///</summary>
    public void SetNanClamp(bool enable)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_nan_clamp(this, enable);
    }

    ///<summary>
    /// Sets the compiler optimization level to the given level. Only the last one takes effect if multiple calls of this function exist.
    ///</summary>
    public void SetOptimizationLevel(ShadercOptimizationLevel level)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_optimization_level(this, level);
    }

    ///<summary>
    /// Sets whether the compiler should preserve all bindings, even when those bindings are not used.
    ///</summary>
    public void SetPreserveBindings(bool preserve_bindings)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_preserve_bindings(this, preserve_bindings);
    }

    ///<summary>
    /// Sets the source language. The default is GLSL.
    ///</summary>
    public void SetSourceLanguage(ShadercSourceLanguage lang)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_source_language(this, lang);
    }

    ///<summary>
    /// Sets the compiler mode to suppress warnings, overriding warnings-as-errors mode. When both suppress-warnings and warnings-as-errors modes are turned on, warning messages will be inhibited, and will not be emitted as error messages.
    ///</summary>
    public void SetSuppressWarnings()
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_suppress_warnings(this);
    }

    ///<summary>
    /// Sets the target shader environment, affecting which warnings or errors will be issued. The version will be for distinguishing between different versions of the target environment. The version value should be either 0 or a value listed in shaderc_env_version. The 0 value maps to Vulkan 1.0 if |target| is Vulkan, and it maps to OpenGL 4.5 if |target| is OpenGL.
    ///</summary>
    public void SetTargetEnv(ShadercTargetEnv target, uint version)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_target_env(this, target, version);
    }

    ///<summary>
    /// Sets the target SPIR-V version. The generated module will use this version of SPIR-V. Each target environment determines what versions of SPIR-V it can consume. Defaults to the highest version of SPIR-V 1.0 which is required to be supported by the target environment. E.g. Default to SPIR-V 1.0 for Vulkan 1.0 and SPIR-V 1.3 for Vulkan 1.1.
    ///</summary>
    public void SetTargetSpirv(ShadercSpirvVersion version)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_target_spirv(this, version);
    }

    ///<summary>
    /// Enables or disables relaxed Vulkan rules.
    ///</summary>
    public void SetVulkanRulesRelaxed(bool enable)
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_vulkan_rules_relaxed(this, enable);
    }

    ///<summary>
    /// Sets the compiler mode to treat all warnings as errors. Note the suppress-warnings mode overrides this option, i.e. if both warning-as-errors and suppress-warnings modes are set, warnings will not be emitted as error messages.
    ///</summary>
    public void SetWarningsAsErrors()
    {
        AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_warnings_as_errors(this);
    }

    public ref readonly ShadercCompileOptions GetPinnableReference() => ref __Instance;

    public static implicit operator AdamantiumVulkan.Shaders.Interop.ShadercCompileOptions(ShadercCompileOptionsT s)
    {
        return s?.__Instance ?? new AdamantiumVulkan.Shaders.Interop.ShadercCompileOptions();
    }

    public static implicit operator ShadercCompileOptionsT(AdamantiumVulkan.Shaders.Interop.ShadercCompileOptions s)
    {
        return new ShadercCompileOptionsT(s);
    }

}



