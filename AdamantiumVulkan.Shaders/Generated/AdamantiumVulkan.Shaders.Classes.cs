// ----------------------------------------------------------------------------------------------
// <auto-generated>
// This file was autogenerated by QuantumBindingGenerator.
// Do not edit this file manually, because you will lose all your changes after next generation.
// </auto-generated>
// ----------------------------------------------------------------------------------------------

namespace AdamantiumVulkan.Shaders
{
    using System;
    using System.Runtime.InteropServices;
    using AdamantiumVulkan.Shaders.Interop;

    ///<summary>
    /// An opaque handle to an object that manages all compiler state.
    ///</summary>
    public partial class ShadercCompilerT
    {
        internal ShadercCompiler __Instance;

        public ShadercCompilerT()
        {
        }

        public ShadercCompilerT(AdamantiumVulkan.Shaders.Interop.ShadercCompiler __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Takes an assembly string of the format defined in the SPIRV-Tools project (https://github.com/KhronosGroup/SPIRV-Tools/blob/master/syntax.md), assembles it into SPIR-V binary and a shaderc_compilation_result will be returned to hold the results. The assembling will pick options suitable for assembling specified in the additional_options parameter. May be safely called from multiple threads without explicit synchronization. If there was failure in allocating the compiler object, null will be returned.
        ///</summary>
        public ShadercCompilationResultT AssembleIntoSpv(string source_assembly, ulong source_assembly_size, AdamantiumVulkan.Shaders.ShadercCompileOptionsT additional_options)
        {
            var arg1 = ReferenceEquals(additional_options, null) ? new ShadercCompileOptions() : (ShadercCompileOptions)additional_options;
            return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_assemble_into_spv(this, source_assembly, source_assembly_size, arg1);
        }

        ///<summary>
        /// Like shaderc_compile_into_spv, but the result contains preprocessed source code instead of a SPIR-V binary module
        ///</summary>
        public ShadercCompilationResultT CompileIntoPreprocessedText(string source_text, ulong source_text_size, ShadercShaderKind shader_kind, string input_file_name, string entry_point_name, AdamantiumVulkan.Shaders.ShadercCompileOptionsT additional_options)
        {
            var arg1 = ReferenceEquals(additional_options, null) ? new ShadercCompileOptions() : (ShadercCompileOptions)additional_options;
            return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_into_preprocessed_text(this, source_text, source_text_size, shader_kind, input_file_name, entry_point_name, arg1);
        }

        ///<summary>
        /// Takes a GLSL source string and the associated shader kind, input file name, compiles it according to the given additional_options. If the shader kind is not set to a specified kind, but shaderc_glslc_infer_from_source, the compiler will try to deduce the shader kind from the source string and a failure in deducing will generate an error. Currently only #pragma annotation is supported. If the shader kind is set to one of the default shader kinds, the compiler will fall back to the default shader kind in case it failed to deduce the shader kind from source string. The input_file_name is a null-termintated string. It is used as a tag to identify the source string in cases like emitting error messages. It doesn't have to be a 'file name'. The source string will be compiled into SPIR-V binary and a shaderc_compilation_result will be returned to hold the results. The entry_point_name null-terminated string defines the name of the entry point to associate with this GLSL source. If the additional_options parameter is not null, then the compilation is modified by any options present. May be safely called from multiple threads without explicit synchronization. If there was failure in allocating the compiler object, null will be returned.
        ///</summary>
        public ShadercCompilationResultT CompileIntoSpv(string source_text, ulong source_text_size, ShadercShaderKind shader_kind, string input_file_name, string entry_point_name, AdamantiumVulkan.Shaders.ShadercCompileOptionsT additional_options)
        {
            var arg1 = ReferenceEquals(additional_options, null) ? new ShadercCompileOptions() : (ShadercCompileOptions)additional_options;
            return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_into_spv(this, source_text, source_text_size, shader_kind, input_file_name, entry_point_name, arg1);
        }

        ///<summary>
        /// Like shaderc_compile_into_spv, but the result contains SPIR-V assembly text instead of a SPIR-V binary module. The SPIR-V assembly syntax is as defined by the SPIRV-Tools open source project.
        ///</summary>
        public ShadercCompilationResultT CompileIntoSpvAssembly(string source_text, ulong source_text_size, ShadercShaderKind shader_kind, string input_file_name, string entry_point_name, AdamantiumVulkan.Shaders.ShadercCompileOptionsT additional_options)
        {
            var arg1 = ReferenceEquals(additional_options, null) ? new ShadercCompileOptions() : (ShadercCompileOptions)additional_options;
            return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_into_spv_assembly(this, source_text, source_text_size, shader_kind, input_file_name, entry_point_name, arg1);
        }

        ///<summary>
        /// Returns a shaderc_compiler_t that can be used to compile modules. A return of NULL indicates that there was an error initializing the compiler. Any function operating on shaderc_compiler_t must offer the basic thread-safety guarantee. [http://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/] That is: concurrent invocation of these functions on DIFFERENT objects needs no synchronization; concurrent invocation of these functions on the SAME object requires synchronization IF AND ONLY IF some of them take a non-const argument.
        ///</summary>
        public static ShadercCompilerT CompilerInitialize()
        {
            return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compiler_initialize();
        }

        ///<summary>
        /// Releases the resources held by the shaderc_compiler_t. After this call it is invalid to make any future calls to functions involving this shaderc_compiler_t.
        ///</summary>
        public void CompilerRelease()
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compiler_release(this);
        }

        public static implicit operator AdamantiumVulkan.Shaders.Interop.ShadercCompiler(ShadercCompilerT s)
        {
            return s?.__Instance ?? new AdamantiumVulkan.Shaders.Interop.ShadercCompiler();
        }

        public static implicit operator ShadercCompilerT(AdamantiumVulkan.Shaders.Interop.ShadercCompiler s)
        {
            return new ShadercCompilerT(){__Instance = s};
        }

    }

    ///<summary>
    /// An opaque handle to an object that manages options to a single compilation result.
    ///</summary>
    public partial class ShadercCompileOptionsT
    {
        internal ShadercCompileOptions __Instance;

        public ShadercCompileOptionsT()
        {
        }

        public ShadercCompileOptionsT(AdamantiumVulkan.Shaders.Interop.ShadercCompileOptions __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Adds a predefined macro to the compilation options. This has the same effect as passing -Dname=value to the command-line compiler. If value is NULL, it has the same effect as passing -Dname to the command-line compiler. If a macro definition with the same name has previously been added, the value is replaced with the new value. The macro name and value are passed in with char pointers, which point to their data, and the lengths of their data. The strings that the name and value pointers point to must remain valid for the duration of the call, but can be modified or deleted after this function has returned. In case of adding a valueless macro, the value argument should be a null pointer or the value_length should be 0u.
        ///</summary>
        public void AddMacroDefinition(string name, ulong name_length, string value, ulong value_length)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_add_macro_definition(this, name, name_length, value, value_length);
        }

        ///<summary>
        /// Returns a copy of the given shaderc_compile_options_t. If NULL is passed as the parameter the call is the same as shaderc_compile_options_init.
        ///</summary>
        public ShadercCompileOptionsT Clone()
        {
            return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_clone(this);
        }

        ///<summary>
        /// Returns a default-initialized shaderc_compile_options_t that can be used to modify the functionality of a compiled module. A return of NULL indicates that there was an error initializing the options. Any function operating on shaderc_compile_options_t must offer the basic thread-safety guarantee.
        ///</summary>
        public static ShadercCompileOptionsT Initialize()
        {
            return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_initialize();
        }

        ///<summary>
        /// Releases the compilation options. It is invalid to use the given shaderc_compile_options_t object in any future calls. It is safe to pass NULL to this function, and doing such will have no effect.
        ///</summary>
        public void Release()
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_release(this);
        }

        ///<summary>
        /// Sets whether the compiler should automatically assign bindings to uniforms that aren't already explicitly bound in the shader source.
        ///</summary>
        public void SetAutoBindUniforms(bool auto_bind)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_auto_bind_uniforms(this, auto_bind);
        }

        ///<summary>
        /// Sets whether the compiler should automatically assign locations to uniform variables that don't have explicit locations in the shader source.
        ///</summary>
        public void SetAutoMapLocations(bool auto_map)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_auto_map_locations(this, auto_map);
        }

        ///<summary>
        /// Sets the base binding number used for for a uniform resource type when automatically assigning bindings. For GLSL compilation, sets the lowest automatically assigned number. For HLSL compilation, the regsiter number assigned to the resource is added to this specified base.
        ///</summary>
        public void SetBindingBase(ShadercUniformKind kind, uint @base)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_binding_base(this, kind, @base);
        }

        ///<summary>
        /// Like shaderc_compile_options_set_binding_base, but only takes effect when compiling a given shader stage. The stage is assumed to be one of vertex, fragment, tessellation evaluation, tesselation control, geometry, or compute.
        ///</summary>
        public void SetBindingBaseForStage(ShadercShaderKind shader_kind, ShadercUniformKind kind, uint @base)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_binding_base_for_stage(this, shader_kind, kind, @base);
        }

        ///<summary>
        /// Forces the GLSL language version and profile to a given pair. The version number is the same as would appear in the #version annotation in the source. Version and profile specified here overrides the #version annotation in the source. Use profile: 'shaderc_profile_none' for GLSL versions that do not define profiles, e.g. versions below 150.
        ///</summary>
        public void SetForcedVersionProfile(int version, ShadercProfile profile)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_forced_version_profile(this, version, profile);
        }

        ///<summary>
        /// Sets the compiler mode to generate debug information in the output.
        ///</summary>
        public void SetGenerateDebugInfo()
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_generate_debug_info(this);
        }

        ///<summary>
        /// Sets whether the compiler should enable extension SPV_GOOGLE_hlsl_functionality1.
        ///</summary>
        public void SetHlslFunctionality1(bool enable)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_hlsl_functionality1(this, enable);
        }

        ///<summary>
        /// Sets whether the compiler should use HLSL IO mapping rules for bindings. Defaults to false.
        ///</summary>
        public void SetHlslIoMapping(bool hlsl_iomap)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_hlsl_io_mapping(this, hlsl_iomap);
        }

        ///<summary>
        /// Sets whether the compiler should determine block member offsets using HLSL packing rules instead of standard GLSL rules. Defaults to false. Only affects GLSL compilation. HLSL rules are always used when compiling HLSL.
        ///</summary>
        public void SetHlslOffsets(bool hlsl_offsets)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_hlsl_offsets(this, hlsl_offsets);
        }

        ///<summary>
        /// Like shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage, but affects all shader stages.
        ///</summary>
        public void SetHlslRegisterSetAndBinding(string reg, string set, string binding)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_hlsl_register_set_and_binding(this, reg, set, binding);
        }

        ///<summary>
        /// Sets a descriptor set and binding for an HLSL register in the given stage. This method keeps a copy of the string data.
        ///</summary>
        public void SetHlslRegisterSetAndBindingForStage(ShadercShaderKind shader_kind, string reg, string set, string binding)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_hlsl_register_set_and_binding_for_stage(this, shader_kind, reg, set, binding);
        }

        ///<summary>
        /// Sets includer callback functions.
        ///</summary>
        public void SetIncludeCallbacks(System.IntPtr resolver, System.IntPtr result_releaser, ref System.IntPtr user_data)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_include_callbacks(this, resolver, result_releaser, user_data);
        }

        ///<summary>
        /// Sets whether the compiler should invert position.Y output in vertex shader.
        ///</summary>
        public void SetInvertY(bool enable)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_invert_y(this, enable);
        }

        ///<summary>
        /// Sets a resource limit.
        ///</summary>
        public void SetLimit(ShadercLimit limit, int value)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_limit(this, limit, value);
        }

        ///<summary>
        /// Sets whether the compiler generates code for max and min builtins which, if given a NaN operand, will return the other operand. Similarly, the clamp builtin will favour the non-NaN operands, as if clamp were implemented as a composition of max and min.
        ///</summary>
        public void SetNanClamp(bool enable)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_nan_clamp(this, enable);
        }

        ///<summary>
        /// Sets the compiler optimization level to the given level. Only the last one takes effect if multiple calls of this function exist.
        ///</summary>
        public void SetOptimizationLevel(ShadercOptimizationLevel level)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_optimization_level(this, level);
        }

        ///<summary>
        /// Sets the source language. The default is GLSL.
        ///</summary>
        public void SetSourceLanguage(ShadercSourceLanguage lang)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_source_language(this, lang);
        }

        ///<summary>
        /// Sets the compiler mode to suppress warnings, overriding warnings-as-errors mode. When both suppress-warnings and warnings-as-errors modes are turned on, warning messages will be inhibited, and will not be emitted as error messages.
        ///</summary>
        public void SetSuppressWarnings()
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_suppress_warnings(this);
        }

        ///<summary>
        /// Sets the target shader environment, affecting which warnings or errors will be issued. The version will be for distinguishing between different versions of the target environment. The version value should be either 0 or a value listed in shaderc_env_version. The 0 value maps to Vulkan 1.0 if |target| is Vulkan, and it maps to OpenGL 4.5 if |target| is OpenGL.
        ///</summary>
        public void SetTargetEnv(ShadercTargetEnv target, uint version)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_target_env(this, target, version);
        }

        ///<summary>
        /// Sets the target SPIR-V version. The generated module will use this version of SPIR-V. Each target environment determines what versions of SPIR-V it can consume. Defaults to the highest version of SPIR-V 1.0 which is required to be supported by the target environment. E.g. Default to SPIR-V 1.0 for Vulkan 1.0 and SPIR-V 1.3 for Vulkan 1.1.
        ///</summary>
        public void SetTargetSpirv(ShadercSpirvVersion version)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_target_spirv(this, version);
        }

        ///<summary>
        /// Sets the compiler mode to treat all warnings as errors. Note the suppress-warnings mode overrides this option, i.e. if both warning-as-errors and suppress-warnings modes are set, warnings will not be emitted as error messages.
        ///</summary>
        public void SetWarningsAsErrors()
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_compile_options_set_warnings_as_errors(this);
        }

        public static implicit operator AdamantiumVulkan.Shaders.Interop.ShadercCompileOptions(ShadercCompileOptionsT s)
        {
            return s?.__Instance ?? new AdamantiumVulkan.Shaders.Interop.ShadercCompileOptions();
        }

        public static implicit operator ShadercCompileOptionsT(AdamantiumVulkan.Shaders.Interop.ShadercCompileOptions s)
        {
            return new ShadercCompileOptionsT(){__Instance = s};
        }

    }

    ///<summary>
    /// An opaque handle to the results of a call to any shaderc_compile_into_*() function.
    ///</summary>
    public partial class ShadercCompilationResultT
    {
        internal ShadercCompilationResult __Instance;

        public ShadercCompilationResultT()
        {
        }

        public ShadercCompilationResultT(AdamantiumVulkan.Shaders.Interop.ShadercCompilationResult __Instance)
        {
            this.__Instance = __Instance;
        }

        ///<summary>
        /// Returns a pointer to the start of the compilation output data bytes, either SPIR-V binary or char string. When the source string is compiled into SPIR-V binary, this is guaranteed to be castable to a uint32_t*. If the result contains assembly text or preprocessed source text, the pointer will point to the resulting array of characters.
        ///</summary>
        public System.IntPtr GetBytes()
        {
            return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_result_get_bytes(this);
        }

        ///<summary>
        /// Returns the compilation status, indicating whether the compilation succeeded, or failed due to some reasons, like invalid shader stage or compilation errors.
        ///</summary>
        public ShadercCompilationStatus GetCompilationStatus()
        {
            return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_result_get_compilation_status(this);
        }

        ///<summary>
        /// Returns a null-terminated string that contains any error messages generated during the compilation.
        ///</summary>
        public string GetErrorMessage()
        {
            return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_result_get_error_message(this);
        }

        ///<summary>
        /// Returns the number of bytes of the compilation output data in a result object.
        ///</summary>
        public ulong GetLength()
        {
            return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_result_get_length(this);
        }

        ///<summary>
        /// Returns the number of errors generated during the compilation.
        ///</summary>
        public ulong GetNumErrors()
        {
            return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_result_get_num_errors(this);
        }

        ///<summary>
        /// Returns the number of warnings generated during the compilation.
        ///</summary>
        public ulong GetNumWarnings()
        {
            return AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_result_get_num_warnings(this);
        }

        ///<summary>
        /// Releases the resources held by the result object. It is invalid to use the result object for any further operations.
        ///</summary>
        public void Release()
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_result_release(this);
        }

        public static implicit operator AdamantiumVulkan.Shaders.Interop.ShadercCompilationResult(ShadercCompilationResultT s)
        {
            return s?.__Instance ?? new AdamantiumVulkan.Shaders.Interop.ShadercCompilationResult();
        }

        public static implicit operator ShadercCompilationResultT(AdamantiumVulkan.Shaders.Interop.ShadercCompilationResult s)
        {
            return new ShadercCompilationResultT(){__Instance = s};
        }

    }

    public static class VulkanShadersNative
    {
        ///<summary>
        /// Provides the version & revision of the SPIR-V which will be produced
        ///</summary>
        public static void GetSpvVersion(ref uint version, ref uint revision)
        {
            AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_get_spv_version(ref version, ref revision);
        }

        ///<summary>
        /// Parses the version and profile from a given null-terminated string containing both version and profile, like: '450core'. Returns false if the string can not be parsed. Returns true when the parsing succeeds. The parsed version and profile are returned through arguments.
        ///</summary>
        public static bool ParseVersionProfile(string str, ref int version, ref ShadercProfile profile)
        {
            var arg0 = (int)profile;
            var result = AdamantiumVulkan.Shaders.Interop.VulkanShadersInterop.shaderc_parse_version_profile(str, ref version, ref arg0);
            profile = (ShadercProfile)arg0;
            return result;
        }

    }

}

