// ----------------------------------------------------------------------------------------------
// <auto-generated>
// This file was autogenerated by QuantumBindingGenerator.
// Do not edit this file manually, because you will lose all your changes after next generation.
// </auto-generated>
// ----------------------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using QuantumBinding.Utils;
using AdamantiumVulkan.Spirv.Cross.Interop;
using AdamantiumVulkan.Spirv.Interop;

namespace AdamantiumVulkan.Spirv.Cross;

///<summary>
/// These types are opaque to the user.
///</summary>
public unsafe partial class SpirvContext
{
    internal SpvcContextS __Instance;
    public SpirvContext()
    {
    }

    public SpirvContext(AdamantiumVulkan.Spirv.Cross.Interop.SpvcContextS __Instance)
    {
        this.__Instance = __Instance;
    }

    ///<summary>
    /// Context is the highest-level API construct. The context owns all memory allocations made by its child object hierarchy, including various non-opaque structs and strings. This means that the API user only has to care about one "destroy" call ever when using the C API. All pointers handed out by the APIs are only valid as long as the context is alive and spvc_context_release_allocations has not been called.
    ///</summary>
    public static Result Create(out AdamantiumVulkan.Spirv.Cross.SpirvContext context)
    {
        SpvcContextS arg0;
        var result = AdamantiumVulkan.Spirv.Cross.Interop.SpirvCrossInterop.spvc_context_create(out arg0);
        context = new SpirvContext(arg0);
        return result;
    }

    ///<summary>
    /// Create a compiler backend. Capture mode controls if we construct by copy or move semantics. It is always recommended to use SPVC_CAPTURE_MODE_TAKE_OWNERSHIP if you only intend to cross-compile the IR once.
    ///</summary>
    public Result CreateCompiler(Backend backend, AdamantiumVulkan.Spirv.Cross.SpirvParsedIr parsed_ir, CaptureMode mode, out AdamantiumVulkan.Spirv.Cross.SpirvCompiler compiler)
    {
        var arg2 = ReferenceEquals(parsed_ir, null) ? new SpvcParsedIrS() : (SpvcParsedIrS)parsed_ir;
        SpvcCompilerS arg4;
        var result = AdamantiumVulkan.Spirv.Cross.Interop.SpirvCrossInterop.spvc_context_create_compiler(this, backend, arg2, mode, out arg4);
        compiler = new SpirvCompiler(arg4);
        return result;
    }

    ///<summary>
    /// Frees all memory allocations and objects associated with the context and its child objects.
    ///</summary>
    public void Destroy()
    {
        AdamantiumVulkan.Spirv.Cross.Interop.SpirvCrossInterop.spvc_context_destroy(this);
    }

    ///<summary>
    /// Get the string for the last error which was logged.
    ///</summary>
    public string GetLastErrorString()
    {
        var result = AdamantiumVulkan.Spirv.Cross.Interop.SpirvCrossInterop.spvc_context_get_last_error_string(this);
        return new string(result);
    }

    ///<summary>
    /// SPIR-V parsing interface. Maps to Parser which then creates a ParsedIR, and that IR is extracted into the handle.
    ///</summary>
    public Result ParseSpirv(in byte[] spirv, ulong word_count, out AdamantiumVulkan.Spirv.Cross.SpirvParsedIr parsed_ir)
    {
        var arg1 = ReferenceEquals(spirv, null) ? null : NativeUtils.ManagedArrayToPointer(spirv);
        SpvcParsedIrS arg3;
        var result = AdamantiumVulkan.Spirv.Cross.Interop.SpirvCrossInterop.spvc_context_parse_spirv(this, arg1, word_count, out arg3);
        parsed_ir = new SpirvParsedIr(arg3);
        return result;
    }

    ///<summary>
    /// Frees all memory allocations and objects associated with the context and its child objects, but keeps the context alive.
    ///</summary>
    public void ReleaseAllocations()
    {
        AdamantiumVulkan.Spirv.Cross.Interop.SpirvCrossInterop.spvc_context_release_allocations(this);
    }

    public void SetErrorCallback(void* cb, void* userdata)
    {
        AdamantiumVulkan.Spirv.Cross.Interop.SpirvCrossInterop.spvc_context_set_error_callback(this, cb, userdata);
    }

    public ref readonly SpvcContextS GetPinnableReference() => ref __Instance;

    public static implicit operator AdamantiumVulkan.Spirv.Cross.Interop.SpvcContextS(SpirvContext s)
    {
        return s?.__Instance ?? new AdamantiumVulkan.Spirv.Cross.Interop.SpvcContextS();
    }

    public static implicit operator SpirvContext(AdamantiumVulkan.Spirv.Cross.Interop.SpvcContextS s)
    {
        return new SpirvContext(s);
    }

}



