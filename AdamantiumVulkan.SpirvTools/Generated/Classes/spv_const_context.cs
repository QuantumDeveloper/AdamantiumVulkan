// ----------------------------------------------------------------------------------------------
// <auto-generated>
// This file was autogenerated by QuantumBindingGenerator.
// Do not edit this file manually, because you will lose all your changes after next generation.
// </auto-generated>
// ----------------------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using QuantumBinding.Utils;
using AdamantiumVulkan.SpirvTools.Interop;

namespace AdamantiumVulkan.SpirvTools;

// File: C:\VulkanSDK\1.3.275.0\Include\spirv-tools\libspirv.h Line: 483 Column: 30
public unsafe partial class spv_const_context
{
    internal spv_context_t __Instance;
    public spv_const_context()
    {
    }

    public spv_const_context(AdamantiumVulkan.SpirvTools.Interop.spv_context_t __Instance)
    {
        this.__Instance = __Instance;
    }

    ///<summary>
    /// Parses a SPIR-V binary, specified as counted sequence of 32-bit words. Parsing feedback is provided via two callbacks provided as function pointers. Each callback function pointer can be a null pointer, in which case it is never called. Otherwise, in a valid parse the parsed-header callback is called once, and then the parsed-instruction callback once for each instruction in the stream. The user_data parameter is supplied as context to the callbacks. Returns SPV_SUCCESS on successful parse where the callbacks always return SPV_SUCCESS. For an invalid parse, returns a status code other than SPV_SUCCESS, and if diagnostic is non-null also emits a diagnostic. If diagnostic is null the context's message consumer will be used to emit any errors. If a callback returns anything other than SPV_SUCCESS, then that status code is returned, no further callbacks are issued, and no additional diagnostics are emitted.
    ///</summary>
    public spv_result_t SpvBinaryParse(ref void* user_data, in uint words, ulong num_words, void* parse_header, void* parse_instruction, out Spv_diagnostic diagnostic)
    {
        var arg2 = NativeUtils.StructOrEnumToPointer(words);
        AdamantiumVulkan.SpirvTools.Interop.spv_diagnostic arg6;
        var result = AdamantiumVulkan.SpirvTools.Interop.SpirvToolsInterop.spvBinaryParse(this, user_data, arg2, num_words, parse_header, parse_instruction, out arg6);
        diagnostic = new Spv_diagnostic(arg6);
        return result;
    }

    ///<summary>
    /// Decodes the given SPIR-V binary representation to its assembly text. The word_count parameter specifies the number of words for binary. The options parameter is a bit field of spv_binary_to_text_options_t. Decoded text will be stored into *text. Any error will be written into *diagnostic if diagnostic is non-null, otherwise the context's message consumer will be used.
    ///</summary>
    public spv_result_t SpvBinaryToText(in byte[] binary, ulong word_count, uint options, out Spv_text text, out Spv_diagnostic diagnostic)
    {
        var arg1 = ReferenceEquals(binary, null) ? null : NativeUtils.ManagedArrayToPointer(binary);
        AdamantiumVulkan.SpirvTools.Interop.spv_text* arg4;
        AdamantiumVulkan.SpirvTools.Interop.spv_diagnostic* arg5;
        var result = AdamantiumVulkan.SpirvTools.Interop.SpirvToolsInterop.spvBinaryToText(this, arg1, word_count, options, out arg4, out arg5);
        NativeUtils.Free(arg1);
        if (arg4 is not null)
        {
            text = new Spv_text(*arg4);
        }
        else
        {
            text = (default);
        }
        if (arg5 is not null)
        {
            diagnostic = new Spv_diagnostic(*arg5);
        }
        else
        {
            diagnostic = (default);
        }
        return result;
    }

    ///<summary>
    /// Encodes the given SPIR-V assembly text to its binary representation. The length parameter specifies the number of bytes for text. Encoded binary will be stored into *binary. Any error will be written into *diagnostic if diagnostic is non-null, otherwise the context's message consumer will be used. The generated binary is independent of the context and may outlive it. The SPIR-V binary version is set to the highest version of SPIR-V supported by the context's target environment.
    ///</summary>
    public spv_result_t SpvTextToBinary(string text, ulong length, out AdamantiumVulkan.SpirvTools.spv_binary binary, out Spv_diagnostic diagnostic)
    {
        var arg1 = (sbyte*)NativeUtils.StringToPointer(text, false);
        spv_binary_t arg3;
        AdamantiumVulkan.SpirvTools.Interop.spv_diagnostic arg4;
        var result = AdamantiumVulkan.SpirvTools.Interop.SpirvToolsInterop.spvTextToBinary(this, arg1, length, out arg3, out arg4);
        NativeUtils.Free(arg1);
        binary = new spv_binary(arg3);
        diagnostic = new Spv_diagnostic(arg4);
        return result;
    }

    ///<summary>
    /// Encodes the given SPIR-V assembly text to its binary representation. Same as spvTextToBinary but with options. The options parameter is a bit field of spv_text_to_binary_options_t.
    ///</summary>
    public spv_result_t SpvTextToBinaryWithOptions(string text, ulong length, uint options, out AdamantiumVulkan.SpirvTools.spv_binary binary, out Spv_diagnostic diagnostic)
    {
        var arg1 = (sbyte*)NativeUtils.StringToPointer(text, false);
        spv_binary_t arg4;
        AdamantiumVulkan.SpirvTools.Interop.spv_diagnostic arg5;
        var result = AdamantiumVulkan.SpirvTools.Interop.SpirvToolsInterop.spvTextToBinaryWithOptions(this, arg1, length, options, out arg4, out arg5);
        NativeUtils.Free(arg1);
        binary = new spv_binary(arg4);
        diagnostic = new Spv_diagnostic(arg5);
        return result;
    }

    ///<summary>
    /// Validates a SPIR-V binary for correctness. Any errors will be written into *diagnostic if diagnostic is non-null, otherwise the context's message consumer will be used.
    ///</summary>
    public spv_result_t SpvValidate(AdamantiumVulkan.SpirvTools.spv_const_binary binary, out Spv_diagnostic diagnostic)
    {
        var arg1 = ReferenceEquals(binary, null) ? new spv_const_binary_t() : (spv_const_binary_t)binary;
        AdamantiumVulkan.SpirvTools.Interop.spv_diagnostic arg2;
        var result = AdamantiumVulkan.SpirvTools.Interop.SpirvToolsInterop.spvValidate(this, arg1, out arg2);
        diagnostic = new Spv_diagnostic(arg2);
        return result;
    }

    ///<summary>
    /// Validates a raw SPIR-V binary for correctness. Any errors will be written into *diagnostic if diagnostic is non-null, otherwise the context's message consumer will be used.
    ///</summary>
    public spv_result_t SpvValidateBinary(in uint words, ulong num_words, out Spv_diagnostic diagnostic)
    {
        var arg1 = NativeUtils.StructOrEnumToPointer(words);
        AdamantiumVulkan.SpirvTools.Interop.spv_diagnostic arg3;
        var result = AdamantiumVulkan.SpirvTools.Interop.SpirvToolsInterop.spvValidateBinary(this, arg1, num_words, out arg3);
        diagnostic = new Spv_diagnostic(arg3);
        return result;
    }

    ///<summary>
    /// Validates a SPIR-V binary for correctness. Uses the provided Validator options. Any errors will be written into *diagnostic if diagnostic is non-null, otherwise the context's message consumer will be used.
    ///</summary>
    public spv_result_t SpvValidateWithOptions(AdamantiumVulkan.SpirvTools.spv_const_validator_options options, AdamantiumVulkan.SpirvTools.spv_const_binary binary, out Spv_diagnostic diagnostic)
    {
        var arg1 = ReferenceEquals(options, null) ? new spv_validator_options_t() : (spv_validator_options_t)options;
        var arg2 = ReferenceEquals(binary, null) ? new spv_const_binary_t() : (spv_const_binary_t)binary;
        AdamantiumVulkan.SpirvTools.Interop.spv_diagnostic arg3;
        var result = AdamantiumVulkan.SpirvTools.Interop.SpirvToolsInterop.spvValidateWithOptions(this, arg1, arg2, out arg3);
        diagnostic = new Spv_diagnostic(arg3);
        return result;
    }

    public ref readonly spv_context_t GetPinnableReference() => ref __Instance;

    public static implicit operator AdamantiumVulkan.SpirvTools.Interop.spv_context_t(spv_const_context s)
    {
        return s?.__Instance ?? new AdamantiumVulkan.SpirvTools.Interop.spv_context_t();
    }

    public static implicit operator spv_const_context(AdamantiumVulkan.SpirvTools.Interop.spv_context_t s)
    {
        return new spv_const_context(s);
    }

}



