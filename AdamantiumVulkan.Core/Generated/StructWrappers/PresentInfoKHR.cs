// ----------------------------------------------------------------------------------------------
// <auto-generated>
// This file was autogenerated by QuantumBindingGenerator.
// Do not edit this file manually, because you will lose all your changes after next generation.
// </auto-generated>
// ----------------------------------------------------------------------------------------------

using System.Runtime.InteropServices;
using QuantumBinding.Utils;
using AdamantiumVulkan.Core.Interop;

namespace AdamantiumVulkan.Core;

public unsafe partial class PresentInfoKHR : QBDisposableObject
{
    private NativeStructArray<AdamantiumVulkan.Core.Interop.VkSemaphore_T> _pWaitSemaphores;

    private NativeStructArray<AdamantiumVulkan.Core.Interop.VkSwapchainKHR_T> _pSwapchains;

    private NativeStructArray<uint> _pImageIndices;

    private NativeStructArray<AdamantiumVulkan.Core.Result> _pResults;

    public PresentInfoKHR()
    {
    }

    public PresentInfoKHR(AdamantiumVulkan.Core.Interop.VkPresentInfoKHR _internal)
    {
        PNext = _internal.pNext;
        WaitSemaphoreCount = _internal.waitSemaphoreCount;
        PWaitSemaphores = new Semaphore[_internal.waitSemaphoreCount];
        var nativeTmpArray0 = NativeUtils.PointerToManagedArray(_internal.pWaitSemaphores, _internal.waitSemaphoreCount);
        for (int i = 0; i < nativeTmpArray0.Length; ++i)
        {
            PWaitSemaphores[i] = new Semaphore(nativeTmpArray0[i]);
        }
        NativeUtils.Free(_internal.pWaitSemaphores);
        SwapchainCount = _internal.swapchainCount;
        PSwapchains = new SwapchainKHR[_internal.swapchainCount];
        var nativeTmpArray1 = NativeUtils.PointerToManagedArray(_internal.pSwapchains, _internal.swapchainCount);
        for (int i = 0; i < nativeTmpArray1.Length; ++i)
        {
            PSwapchains[i] = new SwapchainKHR(nativeTmpArray1[i]);
        }
        NativeUtils.Free(_internal.pSwapchains);
        PImageIndices = new uint[_internal.swapchainCount];
        PImageIndices = NativeUtils.PointerToManagedArray(_internal.pImageIndices, (long)_internal.swapchainCount);
        NativeUtils.Free(_internal.pImageIndices);
        PResults = NativeUtils.PointerToManagedArray(_internal.pResults, _internal.swapchainCount);
    }

    public StructureType SType => StructureType.PresentInfoKhr;
    public void* PNext { get; set; }
    public uint WaitSemaphoreCount { get; set; }
    public Semaphore[] PWaitSemaphores { get; set; }
    public uint SwapchainCount { get; set; }
    public SwapchainKHR[] PSwapchains { get; set; }
    public uint[] PImageIndices { get; set; }
    public Result[] PResults { get; set; }

    public AdamantiumVulkan.Core.Interop.VkPresentInfoKHR ToNative()
    {
        var _internal = new AdamantiumVulkan.Core.Interop.VkPresentInfoKHR();
        if (SType != default)
        {
            _internal.sType = SType;
        }
        _internal.pNext = PNext;
        if (WaitSemaphoreCount != default)
        {
            _internal.waitSemaphoreCount = WaitSemaphoreCount;
        }
        _pWaitSemaphores.Dispose();
        if (PWaitSemaphores != default)
        {
            var tmpArray0 = new AdamantiumVulkan.Core.Interop.VkSemaphore_T[PWaitSemaphores.Length];
            for (int i = 0; i < PWaitSemaphores.Length; ++i)
            {
                tmpArray0[i] = PWaitSemaphores[i];
            }
            _pWaitSemaphores = new NativeStructArray<AdamantiumVulkan.Core.Interop.VkSemaphore_T>(tmpArray0);
            _internal.pWaitSemaphores = _pWaitSemaphores.Handle;
        }
        if (SwapchainCount != default)
        {
            _internal.swapchainCount = SwapchainCount;
        }
        _pSwapchains.Dispose();
        if (PSwapchains != default)
        {
            var tmpArray1 = new AdamantiumVulkan.Core.Interop.VkSwapchainKHR_T[PSwapchains.Length];
            for (int i = 0; i < PSwapchains.Length; ++i)
            {
                tmpArray1[i] = PSwapchains[i];
            }
            _pSwapchains = new NativeStructArray<AdamantiumVulkan.Core.Interop.VkSwapchainKHR_T>(tmpArray1);
            _internal.pSwapchains = _pSwapchains.Handle;
        }
        _pImageIndices.Dispose();
        if (PImageIndices != default)
        {
            var tmpArray2 = new uint[PImageIndices.Length];
            for (int i = 0; i < PImageIndices.Length; ++i)
            {
                tmpArray2[i] = PImageIndices[i];
            }
            _pImageIndices = new NativeStructArray<uint>(tmpArray2);
            _internal.pImageIndices = _pImageIndices.Handle;
        }
        _pResults.Dispose();
        if (PResults != null)
        {
            _pResults = new NativeStructArray<AdamantiumVulkan.Core.Result>(PResults);
            _internal.pResults = _pResults.Handle;
        }
        return _internal;
    }

    protected override void UnmanagedDisposeOverride()
    {
        _pWaitSemaphores.Dispose();
        _pSwapchains.Dispose();
        _pImageIndices.Dispose();
        _pResults.Dispose();
    }


    public static implicit operator PresentInfoKHR(AdamantiumVulkan.Core.Interop.VkPresentInfoKHR p)
    {
        return new PresentInfoKHR(p);
    }

}



