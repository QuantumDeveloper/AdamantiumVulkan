// ----------------------------------------------------------------------------------------------
// <auto-generated>
// This file was autogenerated by QuantumBindingGenerator.
// Do not edit this file manually, because you will lose all your changes after next generation.
// </auto-generated>
// ----------------------------------------------------------------------------------------------

using System.Runtime.InteropServices;
using QuantumBinding.Utils;
using AdamantiumVulkan.Core.Interop;

namespace AdamantiumVulkan.Core;

public unsafe partial class SubmitInfo : QBDisposableObject
{
    private NativeStructArray<VkSemaphore_T> pWaitSemaphores;

    private NativeStructArray<PipelineStageFlagBits> pWaitDstStageMask;

    private NativeStructArray<VkCommandBuffer_T> pCommandBuffers;

    private NativeStructArray<VkSemaphore_T> pSignalSemaphores;

    public SubmitInfo()
    {
    }

    public SubmitInfo(AdamantiumVulkan.Core.Interop.VkSubmitInfo _internal)
    {
        PNext = _internal.pNext;
        WaitSemaphoreCount = _internal.waitSemaphoreCount;
        PWaitSemaphores = new Semaphore[_internal.waitSemaphoreCount];
        var nativeTmpArray0 = NativeUtils.PointerToManagedArray(_internal.pWaitSemaphores, _internal.waitSemaphoreCount);
        for (int i = 0; i < nativeTmpArray0.Length; ++i)
        {
            PWaitSemaphores[i] = new Semaphore(nativeTmpArray0[i]);
        }
        NativeUtils.Free(_internal.pWaitSemaphores);
        PWaitDstStageMask = NativeUtils.PointerToManagedArray(_internal.pWaitDstStageMask, _internal.waitSemaphoreCount);
        CommandBufferCount = _internal.commandBufferCount;
        PCommandBuffers = new CommandBuffer[_internal.commandBufferCount];
        var nativeTmpArray1 = NativeUtils.PointerToManagedArray(_internal.pCommandBuffers, _internal.commandBufferCount);
        for (int i = 0; i < nativeTmpArray1.Length; ++i)
        {
            PCommandBuffers[i] = new CommandBuffer(nativeTmpArray1[i]);
        }
        NativeUtils.Free(_internal.pCommandBuffers);
        SignalSemaphoreCount = _internal.signalSemaphoreCount;
        PSignalSemaphores = new Semaphore[_internal.signalSemaphoreCount];
        var nativeTmpArray2 = NativeUtils.PointerToManagedArray(_internal.pSignalSemaphores, _internal.signalSemaphoreCount);
        for (int i = 0; i < nativeTmpArray2.Length; ++i)
        {
            PSignalSemaphores[i] = new Semaphore(nativeTmpArray2[i]);
        }
        NativeUtils.Free(_internal.pSignalSemaphores);
    }

    public StructureType SType => StructureType.SubmitInfo;
    public void* PNext { get; set; }
    public uint WaitSemaphoreCount { get; set; }
    public Semaphore[] PWaitSemaphores { get; set; }
    public PipelineStageFlagBits[] PWaitDstStageMask { get; set; }
    public uint CommandBufferCount { get; set; }
    public CommandBuffer[] PCommandBuffers { get; set; }
    public uint SignalSemaphoreCount { get; set; }
    public Semaphore[] PSignalSemaphores { get; set; }

    public AdamantiumVulkan.Core.Interop.VkSubmitInfo ToNative()
    {
        var _internal = new AdamantiumVulkan.Core.Interop.VkSubmitInfo();
        _internal.sType = SType;
        _internal.pNext = PNext;
        _internal.waitSemaphoreCount = WaitSemaphoreCount;
        pWaitSemaphores.Dispose();
        if (PWaitSemaphores != null)
        {
            var tmpArray0 = new AdamantiumVulkan.Core.Interop.VkSemaphore_T[PWaitSemaphores.Length];
            for (int i = 0; i < PWaitSemaphores.Length; ++i)
            {
                tmpArray0[i] = PWaitSemaphores[i];
            }
            pWaitSemaphores = new NativeStructArray<VkSemaphore_T>(tmpArray0);
            _internal.pWaitSemaphores = pWaitSemaphores.Handle;
        }
        pWaitDstStageMask.Dispose();
        if (PWaitDstStageMask != null)
        {
            pWaitDstStageMask = new NativeStructArray<PipelineStageFlagBits>(PWaitDstStageMask);
            _internal.pWaitDstStageMask = pWaitDstStageMask.Handle;
        }
        _internal.commandBufferCount = CommandBufferCount;
        pCommandBuffers.Dispose();
        if (PCommandBuffers != null)
        {
            var tmpArray1 = new AdamantiumVulkan.Core.Interop.VkCommandBuffer_T[PCommandBuffers.Length];
            for (int i = 0; i < PCommandBuffers.Length; ++i)
            {
                tmpArray1[i] = PCommandBuffers[i];
            }
            pCommandBuffers = new NativeStructArray<VkCommandBuffer_T>(tmpArray1);
            _internal.pCommandBuffers = pCommandBuffers.Handle;
        }
        _internal.signalSemaphoreCount = SignalSemaphoreCount;
        pSignalSemaphores.Dispose();
        if (PSignalSemaphores != null)
        {
            var tmpArray2 = new AdamantiumVulkan.Core.Interop.VkSemaphore_T[PSignalSemaphores.Length];
            for (int i = 0; i < PSignalSemaphores.Length; ++i)
            {
                tmpArray2[i] = PSignalSemaphores[i];
            }
            pSignalSemaphores = new NativeStructArray<VkSemaphore_T>(tmpArray2);
            _internal.pSignalSemaphores = pSignalSemaphores.Handle;
        }
        return _internal;
    }

    protected override void UnmanagedDisposeOverride()
    {
        pWaitSemaphores.Dispose();
        pWaitDstStageMask.Dispose();
        pCommandBuffers.Dispose();
        pSignalSemaphores.Dispose();
    }


    public static implicit operator SubmitInfo(AdamantiumVulkan.Core.Interop.VkSubmitInfo s)
    {
        return new SubmitInfo(s);
    }

}



